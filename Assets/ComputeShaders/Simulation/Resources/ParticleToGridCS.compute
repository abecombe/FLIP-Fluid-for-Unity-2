#pragma kernel InitGridVelocity
#pragma kernel ParticleToGrid

#pragma multi_compile _ USE_LINEAR_KERNEL USE_QUADRATIC_KERNEL
#pragma multi_compile _ USE_NON_SOLID_CELL_FILTERING

#include "../Common.hlsl"

StructuredBuffer<Particle> _ParticleBufferRead;

StructuredBuffer<uint2> _GridParticleIDBufferRead;

StructuredBuffer<uint> _GridTypeBufferRead;

RWStructuredBuffer<float3> _GridVelocityBufferWrite;
RWStructuredBuffer<float3> _GridOriginalVelocityBufferWrite;

StructuredBuffer<uint> _GridNonSolidCellIDBufferRead;

#if !defined(USE_LINEAR_KERNEL) && !defined(USE_QUADRATIC_KERNEL)
#define USE_LINEAR_KERNEL
#endif

#if defined(USE_LINEAR_KERNEL)
static const int grid_range[6] = { -1, 1, -1, 1, -1, 1 };
#elif defined(USE_QUADRATIC_KERNEL)
static const int grid_range[6] = { -2, 1, -2, 1, -2, 1 };
#endif

[numthreads(128, 1, 1)]
void InitGridVelocity(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    _GridVelocityBufferWrite[c_id] = 0;
    _GridOriginalVelocityBufferWrite[c_id] = 0;
}

[numthreads(128, 1, 1)]
void ParticleToGrid(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = GetCellID(thread_id, _GridNonSolidCellIDBufferRead);
    const int3 c_index = CellIDToCellIndex(c_id);

    const uint c_types = _GridTypeBufferRead[c_id];

    if (IsSolidCell(GetMyType(c_types))) return;

    const float3 position = CellIndexToWorldPos(c_index);
    const float3 position_vx = position + float3(-0.5f * _GridSpacing, 0.0f, 0.0f);
    const float3 position_vy = position + float3(0.0f, -0.5f * _GridSpacing, 0.0f);
    const float3 position_vz = position + float3(0.0f, 0.0f, -0.5f * _GridSpacing);

    float3 sum_weight = 0;
    float3 sum_velocity = 0;

    // calc weight & velocity
    FOR_EACH_NEIGHBOR_CELL_PARTICLE_START(c_index, p_id, _GridParticleIDBufferRead, grid_range)
    {
        const Particle p = _ParticleBufferRead[p_id];

        float3 weight;
        weight.x = GetWeight(p.position, position_vx, _GridInvSpacing);
        weight.y = GetWeight(p.position, position_vy, _GridInvSpacing);
        weight.z = GetWeight(p.position, position_vz, _GridInvSpacing);

        sum_weight += weight;
        sum_velocity += weight * p.velocity;
    }
    FOR_EACH_NEIGHBOR_CELL_PARTICLE_END

    float3 velocity = sum_weight > 0 ? sum_velocity / max(sum_weight, FLT_MIN) : 0.0f;

    EnforceBoundaryCondition(velocity, c_types);

    _GridVelocityBufferWrite[c_id] = velocity;
    _GridOriginalVelocityBufferWrite[c_id] = velocity;
}